'''
University of Pennsylvania, Modlab, June 2013

This suite is a code generator for creating C functions implementing cubic 
interpolatation on lookup tables targeting arbitary functions. Given a target 
python function, a target domain, and a table size the appropriate .c, and .h 
files are generated along with a .py wrapper. The C file is immediatly 
compiled and the rough accuracy estimated emperically.
'''

import numpy
import datetime
import subprocess
import ctypes

class CubicInterpolationGenerator:

################################################################################
  def __init__(self,
               function_name,
               y_value_function,
               y_derivative_function,
               domain,
               table_size):
               
    self.function_name = function_name
    self.y_value_function = y_value_function
    self.y_derivative_function = y_derivative_function
    self.domain = domain
    self.table_size = table_size
    
    # calculate lookup table values
    self._CalculateTable()
    
    # generate code for .c, .h, .py files
    self._WriteFiles()
    
    # compile to .so file from .c/.h for use with the .py
    cfilename = "{function_name}_table{table_size}.c".format(
      function_name = self.function_name,
      table_size=self.table_size
    )
    sofilename = "_{function_name}_table{table_size}.so".format(
      function_name = self.function_name,
      table_size=self.table_size
    )
    compile_command = ["gcc", "-shared", "-fPIC", cfilename, "-o", sofilename]
    subprocess.call(compile_command)
    
    # evaluate performance
    self._Evaluate()


################################################################################
  def _CalculateTable(self):
    self.x = numpy.linspace(self.domain[0], self.domain[1], self.table_size)
    self.dx = (self.domain[1]-self.domain[0]) / (self.table_size-1)
    self.p = self.y_value_function(self.x)
    if not numpy.isfinite(self.p).all():
      raise Exception("Function value infinite/undefined in domain.")
    self.m = self.y_derivative_function(self.x) * self.dx
    if not numpy.isfinite(self.m).all():
      raise Exception("Function derivative infinite/undefined in domain.")


################################################################################
  def _WriteTable(self, values):
    lines = []
    this_line = "  "
    for k in xrange(len(values)):
      this_line = this_line + '{:.9e}f, '.format(values[k])
      if numpy.mod(k+1,4) == 0:
        lines.append(this_line)
        this_line = "  "
    return "\n".join(lines)


################################################################################
  def _WriteHeadline(self):
    headline_string = \
'''University of Pennsylvania, Modlab, June 2013

This file implements a function by cubic interpolation within a lookup table.
This is autogenerated code, produced by cubic_interpolation_generator.py.
Generated {time_string}

Generation Parameters:
  function_name: {function_name}
  domain: {x_min} to {x_max}
  table_size: {table_size}'''
    headline_string = headline_string.format(
      function_name=self.function_name,
      x_min=self.domain[0],
      x_max=self.domain[1],
      table_size=self.table_size,
      time_string=datetime.datetime.today().strftime("%A, %d %B %Y %I:%M %p")
    )
    return headline_string


################################################################################
  def _WritePythonHeadline(self):
    return "# " + self._WriteHeadline().replace("\n", "\n# ")


################################################################################
  def _WriteCHeadline(self):
    return "/* " + self._WriteHeadline().replace("\n", "\n * ") + "\n */"
    

################################################################################
  def _WriteSource(self):
  
    source_string = \
'''{headline}

#include "{function_name}_table{table_size}.h"
#include <stdint.h>

#define {X_MIN}       {x_min:.9e}f
#define {X_MAX}       {x_max:.9e}f
#define {TABLE_SIZE}  {table_size}

// function values
static const float p_table[{TABLE_SIZE}] =
{{
{p_table_block}
}};

// function derivatives, multiplied by (({X_MAX} - {X_MIN})/{TABLE_SIZE})
static const float m_table[{TABLE_SIZE}] =
{{
{m_table_block}
}};

// function evaluation by cubic interpolation in a lookup table
float {function_name}_table{table_size}(float x) {{
  // domain limit checking, saturate return value
  if(x <= {X_MIN})
    return(p_table[0]);
  if(x >= {X_MAX})
    return(p_table[{TABLE_SIZE}-1]);
  
  // find interval and interval fraction
  float t = (x - {X_MIN}) * (({TABLE_SIZE}-1) / ({X_MAX} - {X_MIN}));
  uint8_t index = (uint8_t)t;
  t = t - index;
  
  float t2 = t * t;
  float t3 = t2 * t;
  
  // compute value
  return(
    (2*t3 - 3*t2 + 1) * p_table[index] 
    + (t3 - 2*t2 + t) * m_table[index] 
    + (-2*t3 + 3*t2) * p_table[index+1] 
    + (t3 - t2) * m_table[index+1] 
  );
}}'''
    source_string = source_string.format(
      headline = self._WriteCHeadline(),
      function_name=self.function_name,
      x_min=self.domain[0],
      x_max=self.domain[1],
      table_size=self.table_size,
      p_table_block=self._WriteTable(self.p),
      m_table_block=self._WriteTable(self.m),
      X_MIN="X_MIN_{}".format(self.function_name.upper()),
      X_MAX="X_MAX_{}".format(self.function_name.upper()),
      TABLE_SIZE="TABLE_SIZE_{}".format(self.function_name.upper()),
    )
    return source_string


################################################################################
  def _WriteHeader(self):
  
    source_string = \
'''{headline}

#ifndef {caps_function_name}_TABLE{table_size}_H
#define {caps_function_name}_TABLE{table_size}_H

float {function_name}_table{table_size}(float x);

#endif // {caps_function_name}_TABLE{table_size}_H
'''
    source_string = source_string.format( 
      headline=self._WriteCHeadline(),
      caps_function_name=self.function_name.upper(),
      function_name=self.function_name,
      table_size=self.table_size
    )
    return source_string


################################################################################
  def _WritePython(self):
  
    python_string = \
'''{headline}

from ctypes import *
import os

################################################################################
# Must have already complied to _{function_name}_table{table_size}.so; try:
# gcc -shared -fPIC {function_name}_table{table_size}.c -o _{function_name}_table{table_size}.so

################################################################################
# Configure Access to C Library

# Looks for compiled .so in the same directory as this .py
f = os.path.dirname(__file__) + '/_{function_name}_table{table_size}.so'
a = cdll.LoadLibrary(f);

{function_name}_table{table_size} = a.{function_name}_table{table_size}
{function_name}_table{table_size}.argtypes = [c_float]
{function_name}_table{table_size}.restype = c_float

################################################################################
# Test C Library

if __name__=='__main__':

  import numpy
  
  # print some results
  x = numpy.linspace({x_min}, {x_max}, 10)
  y_interp = numpy.vectorize(asinf_table16)(x)
  print
  print "Example (x, y) pairs:"
  print numpy.concatenate([x.reshape(-1,1),y_interp.reshape(-1,1)], 1)
  
  # calculate error (must define truth values to use)
  #x = numpy.linspace({x_min}, {x_max}, 100000)
  #y = FILL_THIS_IN
  #y_interp = [{function_name}_table{table_size}(val) for val in x]
  #error = numpy.abs(y_interp - y.astype(c_float))
  #max_error = error.max()
  #print "The max error is {{}}".format(max_error)
'''
    python_string = python_string.format(
      headline=self._WritePythonHeadline(),
      function_name=self.function_name,
      table_size=self.table_size,
      x_min=self.domain[0],
      x_max=self.domain[1]
    )
    return python_string


################################################################################
  def _WriteFiles(self):
  
    filename = "{}_table{}.c".format(self.function_name, self.table_size)
    f = open(filename, 'w')
    f.write(self._WriteSource())
    
    filename = "{}_table{}.h".format(self.function_name, self.table_size)
    f = open(filename, 'w')
    f.write(self._WriteHeader())
    
    filename = "{}_table{}.py".format(self.function_name, self.table_size)
    f = open(filename, 'w')
    f.write(self._WritePython())



################################################################################
  def _Evaluate(self):
  
    # import and get handle to code generated function
    module_string = "{}_table{}".format(self.function_name, self.table_size)
    function_string = "{}_table{}".format(self.function_name, self.table_size)
    module = __import__(module_string)
    function = getattr(module, function_string)
    
    # evaluate errors
    x = numpy.linspace(self.domain[0], self.domain[1], 100000)
    #y = numpy.vectorize(self.y_value_function)(x)
    y = numpy.array([self.y_value_function(val) for val in x])
    interp_function = "{}_table{}".format(self.function_name, self.table_size)
    y_interp = numpy.vectorize(function)(x)
    error = numpy.abs(y_interp - y.astype(ctypes.c_float))
    max_error = error.max()
    print "The max error is {}".format(max_error)
    return (max_error, (x, y, y_interp))


################################################################################
if __name__=='__main__':

  func_value = numpy.arccos
  def func_derivative(x): return (-1/(1-x**2)**0.5)

  # generate .c, .h, .py files for an interpolation function
  c = CubicInterpolationGenerator(
    function_name = "acosf",
    y_value_function = func_value,
    y_derivative_function = func_derivative,
    
    #domain=(0,1/2**0.5),
    #table_size=32
    
    domain=(0,0.99999),
    table_size=32
  )
